diff --git a/app/api/go-compare/quick-search/route.ts b/app/api/go-compare/quick-search/route.ts
index ad5985f..cb362cb 100644
--- a/app/api/go-compare/quick-search/route.ts
+++ b/app/api/go-compare/quick-search/route.ts
@@ -77,4 +77,4 @@ export async function POST(request: NextRequest) {
             { status: 500 }
         );
     }
-}
\ No newline at end of file
+}
diff --git a/app/api/upc-scanner/[scanId]/restart/route.ts b/app/api/upc-scanner/[scanId]/restart/route.ts
new file mode 100644
index 0000000..6b1857e
--- /dev/null
+++ b/app/api/upc-scanner/[scanId]/restart/route.ts
@@ -0,0 +1,55 @@
+import { NextRequest, NextResponse } from 'next/server';
+
+export async function POST(
+  req: NextRequest,
+  { params }: { params: Promise<{ scanId: string }> }
+) {
+  try {
+    // Get auth token from cookies
+    const authCookie = req.cookies.get('optisage-token')?.value;
+
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+
+    // Await params since it's a Promise in Next.js 15+
+    const { scanId } = await params;
+    
+    // Forward the request to the backend API
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
+    
+    const response = await fetch(`${baseUrl}/upc-scanner/${scanId}/restart`, {
+      method: 'POST',
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        'Content-Type': 'application/json',
+      },
+    });
+
+    // Check if response is empty before parsing
+    const text = await response.text();
+    
+    // Handle empty response
+    if (!text || text.trim() === '') {
+      return NextResponse.json(
+        { status: 200, message: 'Scan restart initiated', data: null },
+        { status: 200 }
+      );
+    }
+    
+    // Parse JSON if response has content
+    const data = text ? JSON.parse(text) : null;
+
+    // Return the API response
+    return NextResponse.json(data || { status: 200, message: 'Scan restart initiated' }, { status: response.status });
+  } catch (error) {
+    console.error('Error restarting UPC scan:', error);
+    return NextResponse.json(
+      { error: 'Failed to restart UPC scan' },
+      { status: 500 }
+    );
+  }
+}
\ No newline at end of file
diff --git a/app/api/upc-scanner/[scanId]/route.ts b/app/api/upc-scanner/[scanId]/route.ts
new file mode 100644
index 0000000..6e7ee8a
--- /dev/null
+++ b/app/api/upc-scanner/[scanId]/route.ts
@@ -0,0 +1,107 @@
+import { NextRequest, NextResponse } from 'next/server';
+
+export async function DELETE(
+  req: NextRequest,
+  { params }: { params: Promise<{ scanId: string }> }
+) {
+  try {
+    // Get auth token from cookies
+    const authCookie = req.cookies.get('optisage-token')?.value;
+
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+
+    // Await params since it's a Promise in Next.js 15+
+    const { scanId } = await params;
+    
+    // Forward the request to the backend API
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
+    
+    const response = await fetch(`${baseUrl}/upc-scanner/${scanId}`, {
+      method: 'DELETE',
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        'Content-Type': 'application/json',
+      },
+    });
+
+    // Check if response is empty before parsing
+    const text = await response.text();
+    
+    // Handle empty response
+    if (!text || text.trim() === '') {
+      return NextResponse.json(
+        { status: 200, message: 'Scan deleted successfully', data: null },
+        { status: 200 }
+      );
+    }
+    
+    // Parse JSON if response has content
+    const data = text ? JSON.parse(text) : null;
+
+    // Return the API response
+    return NextResponse.json(data || { status: 200, message: 'Scan deleted successfully' }, { status: response.status });
+  } catch (error) {
+    console.error('Error deleting UPC scan:', error);
+    return NextResponse.json(
+      { error: 'Failed to delete UPC scan' },
+      { status: 500 }
+    );
+  }
+}
+
+export async function GET(
+  request: NextRequest,
+  { params }: { params: Promise<{ scanId: string }> }
+) {
+  try {
+    // Await params since it's a Promise in Next.js 15+
+    const { scanId } = await params;
+    
+    // Get auth token from cookies
+    const authCookie = request.cookies.get('optisage-token')?.value;
+
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+    
+    // Forward the request to the backend API
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:8000';
+    
+    console.log(`Fetching from: ${baseUrl}/upc-scanner/${scanId}`);
+    const response = await fetch(`${baseUrl}/upc-scanner/${scanId}`, {
+      method: 'GET',
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        'Content-Type': 'application/json',
+      },
+    });
+    
+    // Check if response is ok
+    if (!response.ok) {
+      return NextResponse.json(
+        { error: `Server responded with status: ${response.status}` },
+        { status: response.status }
+      );
+    }
+    
+    // Get the response data
+    const data = await response.json();
+    
+    // Return the API response
+    return NextResponse.json(data, { status: response.status });
+  } catch (error) {
+    console.error("Error fetching scan details:", error);
+    return NextResponse.json(
+      { error: "Failed to fetch scan details" },
+      { status: 500 }
+    );
+  }
+}
\ No newline at end of file
diff --git a/app/api/upc-scanner/download-template/route.ts b/app/api/upc-scanner/download-template/route.ts
new file mode 100644
index 0000000..43c7645
--- /dev/null
+++ b/app/api/upc-scanner/download-template/route.ts
@@ -0,0 +1,51 @@
+import { NextRequest, NextResponse } from 'next/server';
+
+export async function GET(req: NextRequest) {
+  try {
+    // Get cookies to forward them for authentication
+    const authCookie = req.cookies.get('optisage-token')?.value;
+    
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+    
+    // Forward the request to the actual backend API with authentication
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
+    const response = await fetch(`${baseUrl}/upc-scanner/download-template`, {
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        'Accept': 'application/json',
+      },
+    });
+    
+    if (!response.ok) {
+      const errorText = await response.text();
+      console.error('Error from upstream API:', errorText);
+      return NextResponse.json(
+        { error: 'Failed to download template from API' },
+        { status: response.status }
+      );
+    }
+    
+    // Get the file from the backend API
+    const fileData = await response.arrayBuffer();
+    
+    // Return the file as a response
+    return new NextResponse(fileData, {
+      headers: {
+        'Content-Disposition': 'attachment; filename="upc-template.xlsx"',
+        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
+      },
+    });
+    
+  } catch (error) {
+    console.error('Error proxying template download:', error);
+    return NextResponse.json(
+      { error: 'Failed to download template' },
+      { status: 500 }
+    );
+  }
+}
diff --git a/app/api/upc-scanner/route.ts b/app/api/upc-scanner/route.ts
new file mode 100644
index 0000000..70ed09a
--- /dev/null
+++ b/app/api/upc-scanner/route.ts
@@ -0,0 +1,100 @@
+import { NextRequest, NextResponse } from 'next/server';
+
+export const config = {
+  api: {
+    bodyParser: false, // Disable the default body parser as we're handling multipart form data
+  },
+};
+
+export async function GET(req: NextRequest) {
+  try {
+    // Get auth token from cookies
+    const authCookie = req.cookies.get('optisage-token')?.value;
+
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+
+    // Forward the request to the backend API
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
+    
+    const response = await fetch(`${baseUrl}/upc-scanner`, {
+      method: 'GET',
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        'Content-Type': 'application/json',
+      },
+    });
+
+    // Check if response is ok
+    if (!response.ok) {
+      return NextResponse.json(
+        { error: `Server responded with status: ${response.status}` },
+        { status: response.status }
+      );
+    }
+
+    // Get the response data
+    const data = await response.json();
+
+    // Return the API response
+    return NextResponse.json(data, { status: response.status });
+  } catch (error) {
+    console.error('Error fetching UPC scans:', error);
+    return NextResponse.json(
+      { error: 'Failed to fetch UPC scans' },
+      { status: 500 }
+    );
+  }
+}
+
+export async function POST(req: NextRequest) {
+  try {
+    // Get auth token from cookies
+    const authCookie = req.cookies.get('optisage-token')?.value;
+
+    if (!authCookie) {
+      return NextResponse.json(
+        { error: 'Authentication required' },
+        { status: 401 }
+      );
+    }
+
+    // Get the content type to verify it's a multipart form
+    const contentType = req.headers.get('content-type');
+    if (!contentType || !contentType.includes('multipart/form-data')) {
+      return NextResponse.json(
+        { error: 'Content type must be multipart/form-data' },
+        { status: 400 }
+      );
+    }
+
+    // Forward the request with its body and auth token to the backend API
+    const formData = await req.formData();
+    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
+    
+    const response = await fetch(`${baseUrl}/upc-scanner`, {
+      method: 'POST',
+      headers: {
+        'Authorization': `Bearer ${authCookie}`,
+        // Don't set content-type as fetch will set it automatically with the correct boundary
+      },
+      body: formData,
+    });
+
+    // Get the response data
+    const data = await response.json();
+
+    // Return the API response
+    return NextResponse.json(data, { status: response.status });
+  } catch (error) {
+    console.error('Error uploading UPC scan:', error);
+    return NextResponse.json(
+      { error: 'Failed to upload UPC scan' },
+      { status: 500 }
+    );
+  }
+}
