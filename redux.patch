diff --git a/redux/api/auth.ts b/redux/api/auth.ts
index 41962f7..b1061af 100644
--- a/redux/api/auth.ts
+++ b/redux/api/auth.ts
@@ -165,6 +165,13 @@ export const authApi = createApi({
         body: data,
       }),
     }),
+    updateConnectAmazon: builder.mutation({
+      query: (data) => ({
+        url: "customer/settings/update-amazon-connect-notification",
+        method: "PUT",
+        body: data,
+      }),
+    }),
     getPricing: builder.query<any, {}>({
       query: () => ({
         url: "pricing/new",
@@ -218,5 +225,6 @@ export const {
   useLazyGetCountriesQuery,
   useLazyGetExperinceLevelQuery,
   useLazyGetProductCategoriesQuery,
-  useUpdateUserMutation
+  useUpdateUserMutation,
+  useUpdateConnectAmazonMutation
 } = authApi;
diff --git a/redux/api/monitorApi.ts b/redux/api/monitorApi.ts
new file mode 100644
index 0000000..42c9fcf
--- /dev/null
+++ b/redux/api/monitorApi.ts
@@ -0,0 +1,90 @@
+import { createApi } from "@reduxjs/toolkit/query/react";
+import { baseQuery } from "../queryInterceptor";
+
+export const monitorApi = createApi({
+  reducerPath: "monitorApi",
+  refetchOnReconnect: true,
+  refetchOnMountOrArgChange: 10,
+  baseQuery: baseQuery,
+  tagTypes: ["MonitoredSellers"],
+  endpoints: (builder) => ({
+    monitorSeller: builder.mutation<
+      { success: boolean; message: string },
+      { sellerId: string; marketplaceId: number }
+    >({
+      query: ({ sellerId, marketplaceId }) => ({
+        url: "sellers/monitor",
+        method: "POST",
+        body: { seller_id: sellerId, marketplace_id: marketplaceId },
+      }),
+      invalidatesTags: ["MonitoredSellers"],
+    }),
+    
+    unmonitorSeller: builder.mutation<
+      { success: boolean; message: string },
+      { sellerId: string; marketplaceId: number }
+    >({
+      query: ({ sellerId, marketplaceId }) => ({
+        url: "sellers/unmonitor",
+        method: "POST",
+        body: { seller_id: sellerId, marketplace_id: marketplaceId },
+      }),
+      invalidatesTags: ["MonitoredSellers"],
+    }),
+    
+    getMonitoredSellers: builder.query<
+      {
+        status: number;
+        message: string;
+        data: Array<{
+          id: number;
+          seller_id: string;
+          seller_name: string;
+          seller_amazon_link: string;
+          rating: {
+            count: number;
+            stars: number;
+            percentage_change: number | null;
+            change_type: string | null;
+          };
+          marketplace: {
+            id: number;
+            name: string;
+            currency_symbol: string;
+            currency_code: string;
+          };
+          products_count: number;
+          monitoring_since: string;
+          last_updated: string;
+        }>;
+        responseCode: string;
+        meta: {
+          current_page: number;
+          per_page: number;
+          total: number;
+          pagination: {
+            current_page: number;
+            total_pages: number;
+            per_page: number;
+            total: number;
+            has_next_page: boolean;
+            has_previous_page: boolean;
+          };
+        };
+      },
+      { page?: number; per_page?: number, id?: number }
+    >({
+      query: ({id, page = 1, per_page = 20 } = {}) => ({
+        url: `sellers/monitored?marketplace_id=${id}&page=${page}&per_page=${per_page}`,
+        method: "GET",
+      }),
+      providesTags: ["MonitoredSellers"],
+    }),
+  }),
+});
+
+export const {
+  useMonitorSellerMutation,
+  useUnmonitorSellerMutation,
+  useGetMonitoredSellersQuery,
+} = monitorApi; 
\ No newline at end of file
diff --git a/redux/api/quickSearchApi.ts b/redux/api/quickSearchApi.ts
index 9203f16..bca62f9 100644
--- a/redux/api/quickSearchApi.ts
+++ b/redux/api/quickSearchApi.ts
@@ -1,36 +1,65 @@
 import { createApi } from "@reduxjs/toolkit/query/react";
-import { baseQueryWithInterceptor } from "../queryInterceptor";
+import { goCompareQuery } from "../queryInterceptor";
 
 export const quickSearchApi = createApi({
     reducerPath: "quickSearchApi",
     refetchOnReconnect: true,
     refetchOnMountOrArgChange: 10,
-    baseQuery: baseQueryWithInterceptor,
+    baseQuery: goCompareQuery,
     endpoints: (builder) => ({
         getAllCountries: builder.query({
             query: () => ({
-                url: "countries?include=stores",
+                url: "/go-compare/countries",
                 method: "GET",
-                meta: { server: 'test' }
             }),
         }),
         quickSearch: builder.query({
-            query: ({ store_names, asin, country_ids, queue}: {store_names: string[]; asin: string; country_ids: string; queue: boolean}) => {
-                const storeNamesParam = store_names
-                    .map(name => encodeURIComponent(name))
-                    .join(',');
-                return {
-                    url: `quick-search?stores=${storeNamesParam}&asin=${asin}&country_id=${country_ids}&queue=${queue}&group_by=flat`,
-                    method: "GET",
-                    meta: { server: 'test' }
-                }
-            },
+            query: ({ asin, marketplace_id, queue }: { asin: string; marketplace_id: number; queue: boolean }) => ({
+                url: "/go-compare/quick-search",
+                method: "POST",
+                body: {
+                    asin_upc: asin,
+                    marketplace_id: marketplace_id
+                },
+                meta: { endpointHeader: '/quick-search', }
+            }),
         }),
         searchHistory: builder.query({
-            query: () => ({
-                url: `search?include=store,marketplace,country`,
+            query: ({ page, perPage }) => ({
+                url: `/go-compare/search-history?page=${page}&per_page=${perPage}`,
+                method: "GET",
+            }),
+        }),
+        getSearchById: builder.query({
+            query: ({ id }) => ({
+                url: `team-b/reroute?id=${id}`,
+                method: "GET",
+                meta: { endpointHeader: 'search-history/results' }
+            }),
+        }),
+        reverseSearch: builder.query({
+            query: ({ queryName, store, perPage, sortBy, sortOrder }) => ({
+                url: `team-b/reroute?store=${encodeURIComponent(store)}&product_name=${queryName}&limit=${perPage}&sort_by=${sortBy}&sort_order=${sortOrder}`,
+                method: "GET",
+                meta: { endpointHeader: '/reverse-arbitrage', }
+            }),
+        }),
+        getProductDetails: builder.query({
+            query: ({ asin, marketplace_id }) => ({
+                url: `team-b/products/details?asin=${asin}&marketplace_id=${marketplace_id}`,
+                method: "GET",
+            }),
+        }),
+        getComparisonProductDetails: builder.query({
+            query: ({ asin, marketplace_id, sales_price }) => ({
+                url: `/go-compare/product-details?asin=${asin}&marketplace_id=${marketplace_id}${sales_price ? `&sales_price=${sales_price}` : ''}`,
+                method: "GET",
+            }),
+        }),
+        refreshQuickSearch: builder.query({
+            query: ({ searchId, perPage = 10 }: { searchId: string | number; perPage?: number }) => ({
+                url: `/go-compare/quick-search/${searchId}?perPage=${perPage}`,
                 method: "GET",
-                meta: { server: 'test' }
             }),
         }),
     }),
@@ -38,6 +67,17 @@ export const quickSearchApi = createApi({
 
 export const {
     useLazyGetAllCountriesQuery,
-    useLazyQuickSearchQuery,
-    useSearchHistoryQuery
+    useQuickSearchQuery,
+    useSearchHistoryQuery,
+    useGetSearchByIdQuery,
+    useReverseSearchQuery,
+    useGetProductDetailsQuery,
+    useLazyGetProductDetailsQuery,
+    useGetComparisonProductDetailsQuery,
+    useLazyGetComparisonProductDetailsQuery,
+    useRefreshQuickSearchQuery,
+    useLazyRefreshQuickSearchQuery
 } = quickSearchApi;
+
+
+
diff --git a/redux/api/sellerApi.ts b/redux/api/sellerApi.ts
index bcb5c67..fd52e5b 100644
--- a/redux/api/sellerApi.ts
+++ b/redux/api/sellerApi.ts
@@ -48,7 +48,9 @@ export const sellerApi = createApi({
         if (params.minBsr) queryParams.minBsr = params.minBsr;
         if (params.maxBsr) queryParams.maxBsr = params.maxBsr;
         if (params.q) queryParams.q = params.q;
+        if (params.brandName) queryParams.brandName = params.brandName;
         if (params.pageToken) queryParams.pageToken = params.pageToken;
+        if (params.categoryId) queryParams.categoryId = params.categoryId;
 
         return {
           url: `sellers/${sellerId}/products`,
diff --git a/redux/api/totanAi.ts b/redux/api/totanAi.ts
new file mode 100644
index 0000000..9389f91
--- /dev/null
+++ b/redux/api/totanAi.ts
@@ -0,0 +1,52 @@
+import { createApi } from '@reduxjs/toolkit/query/react';
+import { baseQueryForAuth } from '../queryInterceptor';
+
+
+
+export const totanApi = createApi({
+  reducerPath: 'totan',
+  baseQuery: baseQueryForAuth,
+  endpoints: (builder) => ({
+    
+    chat: builder.mutation({
+      query: (data) => ({
+        url: `totan-ai/chat`,
+        method: 'POST',
+        body:data
+      }),
+    }),
+   
+    analyze: builder.mutation({
+      query: (data) => ({
+        url: `totan-ai/analyze`,
+        method: 'POST',
+        body: data
+      }),
+    }),
+   
+    purchaseQuantity: builder.query({
+      query: (asin) => ({
+        url: `totan-ai/purchase-quantity/${asin}`,
+        method: 'GET',
+        
+      }),
+    }),
+    chatHistory: builder.query({
+      query: (sessionId) => ({
+        url: `totan-ai/session/${sessionId}`,
+        method: 'GET',
+        
+      }),
+    }),
+   
+    
+  }),
+});
+
+export const {
+    useChatMutation,
+    useAnalyzeMutation,
+    useLazyPurchaseQuantityQuery,
+    useLazyChatHistoryQuery
+ 
+  } = totanApi; 
\ No newline at end of file
diff --git a/redux/api/user.ts b/redux/api/user.ts
index 071c644..6dbe601 100644
--- a/redux/api/user.ts
+++ b/redux/api/user.ts
@@ -42,6 +42,30 @@ export const userApi = createApi({
         method: "GET",
       }),
     }),
+    getNotifications: builder.query({
+      query: () => ({
+        url: "customer/notifications",
+        method: "GET",
+      }),
+    }),
+    markRead: builder.mutation({
+      query: (id) => ({
+        url: `customer/notifications/${id}`,
+        method: "PUT",
+      }),
+    }),
+    markAllRead: builder.mutation({
+      query: (id) => ({
+        url: `customer/notifications/mark-all-read`,
+        method: "PUT",
+      }),
+    }),
+    deleteAllNotification: builder.mutation({
+      query: (id) => ({
+        url: `customer/notifications/delete-all`,
+        method: "DELETE",
+      }),
+    }),
   }),
 });
 
@@ -49,6 +73,10 @@ export const {
  useLazyGetReferralsQuery,
  useLazyGetSettingsQuery,
  useUpdateSettingsMutation,
- useLazyGetSubscriptionsQuery
+ useLazyGetSubscriptionsQuery,
+ useLazyGetNotificationsQuery,
+ useMarkReadMutation,
+ useMarkAllReadMutation,
+ useDeleteAllNotificationMutation
 
 } = userApi;
diff --git a/redux/queryInterceptor.tsx b/redux/queryInterceptor.tsx
index ba966f8..83eda59 100644
--- a/redux/queryInterceptor.tsx
+++ b/redux/queryInterceptor.tsx
@@ -6,15 +6,17 @@ import {
 } from "@reduxjs/toolkit/query";
 
 import {
-  setNotAuthorized,
-  setServerError,
   updateIdleTimeOut,
 } from "./slice/authSlice";
 
 import Cookies from "js-cookie";
 import { getExtensionToken } from "@/utils/extension";
+
+interface GocompareFetchArgs extends FetchArgs {
+  meta?: { endpointHeader?: string };
+}
+
 export const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
-export const testUrl = process.env.NEXT_PUBLIC_BASE_TEST_URL;
 
 export const baseQueryWithOutToken = fetchBaseQuery({
   baseUrl: `${baseUrl}`,
@@ -24,20 +26,6 @@ export const baseQueryWithOutToken = fetchBaseQuery({
   },
 });
 
-// export const baseQuery = fetchBaseQuery({
-//     baseUrl: `${baseUrl}`,
-//     prepareHeaders: (headers) => {
-//         //const token = sessionStorage.getItem('token')
-//         const token = Cookies.get('optisage-token');
-//         if (token) {
-//             headers.set('authorization', `Bearer ${token}`)
-//         }
-//         headers.set('Accept', 'application/json')
-//         return headers
-//     },
-
-// })
-
 export const baseQuery = fetchBaseQuery({
   baseUrl: `${baseUrl}`,
   prepareHeaders: async (headers) => {
@@ -71,55 +59,27 @@ export const baseQuery = fetchBaseQuery({
   },
 });
 
-export const testQuery = fetchBaseQuery({
-  baseUrl: `${testUrl}`,
-  prepareHeaders: (headers) => {
-    const token = Cookies.get('optisage-token');
-    if (token) {
-      headers.set('authorization', `Bearer ${token}`)
-    }
-    headers.set('Accept', 'application/json')
-    return headers
-  },
-
-})
-
-export const baseQueryWithInterceptor: BaseQueryFn<
-  string | FetchArgs,
-  unknown,
-  FetchBaseQueryError
-> = async (args, api, extraOptions) => {
 
-  const isTestServer = typeof args === 'object' && args !== null && 'meta' in args && typeof (args as any).meta === 'object' && (args as any).meta?.server === 'test';
+export const goCompareQuery: BaseQueryFn<string | FetchArgs, unknown, FetchBaseQueryError> = async (args, api, extraOptions) => {
+  let modifiedArgs: FetchArgs | string = args;
 
-  const selectedBaseQuery = isTestServer ? testQuery : baseQuery;
-  const result: any = await selectedBaseQuery(args, api, extraOptions);
+  if (typeof args === "object") {
+    const customArgs = args as GocompareFetchArgs;
+    const endpointPath = customArgs.meta?.endpointHeader;
 
-  api.dispatch(updateIdleTimeOut());
-  // Check if the response has a status code of 401
-  if (result.error?.status === 401 || result.error?.originalStatus === 401) {
-    api.dispatch(setNotAuthorized());
-    sessionStorage.removeItem("token");
-  }
-  if (result.error?.status === 403 || result.error?.originalStatus === 403) {
-    // api.dispatch(setNotAuthorized())
-    // message.error("Method Not Allowed");
-  }
-  if (result.error?.status === 404 || result.error?.originalStatus === 404) {
-    // message.error("Not Found");
-  }
-  if (result.error?.status === 503 || result.error?.originalStatus === 503) {
-    // api.dispatch(setNotAuthorized())
-    // message.error("Under Maintenance");
+    modifiedArgs = {
+      ...args,
+      headers: {
+        ...(args.headers || {}),
+        ...(endpointPath ? { "x-endpoint": endpointPath } : {}),
+      },
+    };
   }
-  if (result.error?.status === 500 || result.error?.originalStatus === 500) {
-    api.dispatch(setServerError());
-    // message.error("Server Error");
-    // window.location.href = "/serverError";
-  }
-  return result;
+
+  return baseQuery(modifiedArgs, api, extraOptions);
 };
 
+
 export const baseQueryForAuth: BaseQueryFn<
   string | FetchArgs,
   unknown,
diff --git a/redux/slice/chatSlice.ts b/redux/slice/chatSlice.ts
new file mode 100644
index 0000000..876087a
--- /dev/null
+++ b/redux/slice/chatSlice.ts
@@ -0,0 +1,324 @@
+import { createSlice, PayloadAction } from "@reduxjs/toolkit";
+
+type Message = {
+  sender: "ai" | "user";
+  text: string;
+  type?: "analysis" | "chat" | "system" | "error" | "retry";
+  timestamp: number;
+  retryAction?: () => void;
+};
+
+type ConversationState =
+  | "waiting_for_asin"
+  | "waiting_for_cost_price"
+  | "waiting_for_fulfillment"
+  | "analyzing"
+  | "chat_ready";
+
+type AnalysisData = {
+  session_id: string;
+  score: number;
+  category: string;
+  breakdown: {
+    amazon_on_listing: number;
+    fba_sellers: number;
+    buy_box_eligible: number;
+    variation_listing: number;
+    sales_rank_impact: number;
+    estimated_demand: number;
+    offer_count: number;
+    profitability: number;
+  };
+  roi: number;
+  profit_margin: number;
+  monthly_sales: number;
+};
+
+type ChatSession = {
+  id: string;
+  messages: Message[];
+  conversationState: ConversationState;
+  sessionId: string | null;
+  analysisData: AnalysisData | null;
+  collectedData: {
+    asin: string;
+    costPrice: number;
+    isAmazonFulfilled: boolean;
+  };
+  createdAt: number;
+  lastActiveAt: number;
+};
+
+interface ChatState {
+  sessions: Record<string, ChatSession>;
+  currentSessionId: string | null;
+  maxSessions: number;
+}
+
+const initialState: ChatState = {
+  sessions: {},
+  currentSessionId: null,
+  maxSessions: 10, // Limit to prevent storage bloat
+};
+
+const chatSlice = createSlice({
+  name: "chat",
+  initialState,
+  reducers: {
+    // Create a new chat session with optional user name
+    createNewSession: (state, action: PayloadAction<{ firstName?: string } | undefined>) => {
+      const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+      const firstName = action.payload?.firstName;
+      
+      // Remove oldest session if we exceed max sessions
+      const sessionIds = Object.keys(state.sessions);
+      if (sessionIds.length >= state.maxSessions) {
+        const oldestSession = sessionIds.reduce((oldest, current) => 
+          state.sessions[current].lastActiveAt < state.sessions[oldest].lastActiveAt ? current : oldest
+        );
+        delete state.sessions[oldestSession];
+      }
+
+      const welcomeMessage = firstName 
+        ? `Hi ${firstName}, Welcome to Totan AI! ðŸš€`
+        : "Welcome to Totan AI! ðŸš€";
+
+      const newSession: ChatSession = {
+        id: sessionId,
+        messages: [
+          { 
+            sender: "ai", 
+            text: welcomeMessage,
+            timestamp: Date.now()
+          },
+          {
+            sender: "ai",
+            text: "I'll help you analyze Amazon products. Let's start!",
+            timestamp: Date.now() + 1
+          },
+          {
+            sender: "ai",
+            text: "Please provide the ASIN number of the product you'd like to analyze.",
+            timestamp: Date.now() + 2
+          },
+        ],
+        conversationState: "waiting_for_asin",
+        sessionId: null,
+        analysisData: null,
+        collectedData: {
+          asin: "",
+          costPrice: 0,
+          isAmazonFulfilled: false,
+        },
+        createdAt: Date.now(),
+        lastActiveAt: Date.now(),
+      };
+
+      state.sessions[sessionId] = newSession;
+      state.currentSessionId = sessionId;
+    },
+
+    // Set current active session
+    setCurrentSession: (state, action: PayloadAction<string>) => {
+      if (state.sessions[action.payload]) {
+        state.currentSessionId = action.payload;
+        state.sessions[action.payload].lastActiveAt = Date.now();
+      }
+    },
+
+    // Add message to current session
+    addMessage: (state, action: PayloadAction<Omit<Message, 'timestamp'>>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        const message: Message = {
+          ...action.payload,
+          timestamp: Date.now(),
+        };
+        state.sessions[state.currentSessionId].messages.push(message);
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Add multiple messages to current session
+    addMessages: (state, action: PayloadAction<Omit<Message, 'timestamp'>[]>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        const messages: Message[] = action.payload.map((msg, index) => ({
+          ...msg,
+          timestamp: Date.now() + index,
+        }));
+        state.sessions[state.currentSessionId].messages.push(...messages);
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Update conversation state
+    updateConversationState: (state, action: PayloadAction<ConversationState>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        state.sessions[state.currentSessionId].conversationState = action.payload;
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Update session ID (for API tracking)
+    updateSessionId: (state, action: PayloadAction<string>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        state.sessions[state.currentSessionId].sessionId = action.payload;
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Update analysis data
+    updateAnalysisData: (state, action: PayloadAction<AnalysisData>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        state.sessions[state.currentSessionId].analysisData = action.payload;
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Update collected data
+    updateCollectedData: (state, action: PayloadAction<Partial<ChatSession['collectedData']>>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        state.sessions[state.currentSessionId].collectedData = {
+          ...state.sessions[state.currentSessionId].collectedData,
+          ...action.payload,
+        };
+        state.sessions[state.currentSessionId].lastActiveAt = Date.now();
+      }
+    },
+
+    // Delete a specific session
+    deleteSession: (state, action: PayloadAction<string>) => {
+      delete state.sessions[action.payload];
+      if (state.currentSessionId === action.payload) {
+        // Set current session to the most recent one, or null if none exist
+        const sessionIds = Object.keys(state.sessions);
+        if (sessionIds.length > 0) {
+          state.currentSessionId = sessionIds.reduce((latest, current) => 
+            state.sessions[current].lastActiveAt > state.sessions[latest].lastActiveAt ? current : latest
+          );
+        } else {
+          state.currentSessionId = null;
+        }
+      }
+    },
+
+    // Clear all sessions
+    clearAllSessions: (state) => {
+      state.sessions = {};
+      state.currentSessionId = null;
+    },
+
+    // Start new analysis in current session (keeps previous messages)
+    startNewAnalysisInSession: (state, action: PayloadAction<{ firstName?: string } | undefined>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        const session = state.sessions[state.currentSessionId];
+        const firstName = action.payload?.firstName;
+        
+        // Add separator and new analysis messages to existing conversation
+        const separatorMessage = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€";
+        const welcomeMessage = firstName 
+          ? `Hi ${firstName}, let's analyze another product! ðŸš€`
+          : "Let's analyze another product! ðŸš€";
+
+        const newMessages: Message[] = [
+          {
+            sender: "ai",
+            text: separatorMessage,
+            type: "system",
+            timestamp: Date.now()
+          },
+          { 
+            sender: "ai", 
+            text: welcomeMessage,
+            timestamp: Date.now() + 1
+          },
+          {
+            sender: "ai",
+            text: "Please provide the ASIN number of the product you'd like to analyze.",
+            timestamp: Date.now() + 2
+          },
+        ];
+
+        session.messages.push(...newMessages);
+        session.conversationState = "waiting_for_asin";
+        session.sessionId = null;
+        session.analysisData = null;
+        session.collectedData = {
+          asin: "",
+          costPrice: 0,
+          isAmazonFulfilled: false,
+        };
+        session.lastActiveAt = Date.now();
+      }
+    },
+
+    // Reset current session (for new analysis) with optional user name
+    resetCurrentSession: (state, action: PayloadAction<{ firstName?: string } | undefined>) => {
+      if (state.currentSessionId && state.sessions[state.currentSessionId]) {
+        const session = state.sessions[state.currentSessionId];
+        const firstName = action.payload?.firstName;
+        
+        const welcomeMessage = firstName 
+          ? `Hi ${firstName}, Welcome to Totan AI! ðŸš€`
+          : "Welcome to Totan AI! ðŸš€";
+
+        session.messages = [
+          { 
+            sender: "ai", 
+            text: welcomeMessage,
+            timestamp: Date.now()
+          },
+          {
+            sender: "ai",
+            text: "I'll help you analyze Amazon products. Let's start!",
+            timestamp: Date.now() + 1
+          },
+          {
+            sender: "ai",
+            text: "Please provide the ASIN number of the product you'd like to analyze.",
+            timestamp: Date.now() + 2
+          },
+        ];
+        session.conversationState = "waiting_for_asin";
+        session.sessionId = null;
+        session.analysisData = null;
+        session.collectedData = {
+          asin: "",
+          costPrice: 0,
+          isAmazonFulfilled: false,
+        };
+        session.lastActiveAt = Date.now();
+      }
+    },
+  },
+});
+
+export const {
+  createNewSession,
+  setCurrentSession,
+  addMessage,
+  addMessages,
+  updateConversationState,
+  updateSessionId,
+  updateAnalysisData,
+  updateCollectedData,
+  deleteSession,
+  clearAllSessions,
+  startNewAnalysisInSession,
+  resetCurrentSession,
+} = chatSlice.actions;
+
+export default chatSlice.reducer;
+
+// Selectors
+export const selectCurrentSession = (state: { chat: ChatState }) => {
+  if (!state.chat.currentSessionId) return null;
+  return state.chat.sessions[state.chat.currentSessionId] || null;
+};
+
+export const selectAllSessions = (state: { chat: ChatState }) => {
+  return Object.values(state.chat.sessions).sort((a, b) => b.lastActiveAt - a.lastActiveAt);
+};
+
+export const selectSessionById = (state: { chat: ChatState }, sessionId: string) => {
+  return state.chat.sessions[sessionId] || null;
+};
\ No newline at end of file
diff --git a/redux/store.ts b/redux/store.ts
index 1387e23..9b86935 100644
--- a/redux/store.ts
+++ b/redux/store.ts
@@ -1,6 +1,7 @@
 import { combineReducers, configureStore } from "@reduxjs/toolkit";
 import authReducer from "./slice/authSlice";
 import globalReducer from "./slice/globalSlice";
+import chatReducer from "./slice/chatSlice"; // Add this import
 import { authApi } from "./api/auth";
 import { subscriptionApi } from "./api/subscriptionApi";
 import { productsApi } from "./api/productsApi";
@@ -10,11 +11,14 @@ import { userApi } from "./api/user";
 import { sellerApi } from "./api/sellerApi";
 import { quickSearchApi } from "./api/quickSearchApi";
 import { keepaApi } from "./api/keepa";
+import { monitorApi } from "./api/monitorApi";
+import { totanApi } from "./api/totanAi";
 
 
 const rootReducer = combineReducers({
   api: authReducer,
   global: globalReducer,
+  chat: chatReducer, // Add the chat reducer
   [authApi.reducerPath]: authApi.reducer,
   [userApi.reducerPath]: userApi.reducer,
   [subscriptionApi.reducerPath]: subscriptionApi.reducer,
@@ -22,13 +26,15 @@ const rootReducer = combineReducers({
   [sellerApi.reducerPath]: sellerApi.reducer,
   [quickSearchApi.reducerPath]: quickSearchApi.reducer,
   [keepaApi.reducerPath]: keepaApi.reducer,
+  [monitorApi.reducerPath]: monitorApi.reducer,
+  [totanApi.reducerPath]: totanApi.reducer
 
 });
 
 const persistConfig = {
   key: "root",
   storage,
-  whitelist: ["api", "global"], // Whitelist the reducers you want to persist
+  whitelist: ["api", "global"], // Only persist necessary reducers
 };
 const persistedReducer = persistReducer(persistConfig, rootReducer);
 
@@ -46,6 +52,8 @@ export const store = configureStore({
       sellerApi.middleware,
       quickSearchApi.middleware,
       keepaApi.middleware,
+      monitorApi.middleware,
+      totanApi.middleware
     ]),
 });
 
